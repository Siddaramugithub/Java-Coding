
What is restful?
	REST (REpresentational State Transfer) is an architectural style for developing web services.Restful is implements the REST architectural style.
	REST is an architectural style which is based on web-standards and the HTTP protocol. 
	 A resource is accessed via a common interface based on the HTTP standard methods. 
	 A REST client can access and modify the REST resources.
	 REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation).


	
RESTFul Principles and Constraints
The architecture is client/server, stateless, layered, and supports caching –
1)RESTFul Client-Server:
	Client-server is the typical architecture where the server can be the web server hosting the application, and the client can be as simple as the web browser.
	The client send's a request to the web service on the server. The server would either reject the request or comply and provide an adequate response to the client.
2)Stateless:
	Stateless means that the state of the application is not maintained in REST.
	For example, if you delete a resource from a server using the DELETE command, you cannot expect that delete information 	to be passed to the next request.
3)Cache:
	The Cache concept is to help with the problem of stateless which was described in the last point. 
	Since each server client request is independent in nature, sometimes the client might ask the server for the same 	request again. 
	This request will go to the server, and the server will give a response. This increases the traffic across the network. The cache is a concept implemented on the client to store requests which have already been sent to the server. So if the same request is given by the client, instead of going to the server, it would go to the cache and get the required information. 
 4)Layered System
	The concept of a layered system is that any additional layer such as a middleware layer can be inserted between the client and the actual server hosting the RESTFul web service (The middleware layer is where all the business logic is created. This can be an extra service created with which the client could interact with before it makes a call to the web service.). But the introduction of this layer needs to be transparent so that it does not disturb the interaction between the client and the server.

5)Interface/Uniform Contract
	This is the underlying technique of how RESTful web services should work. RESTful basically works on the HTTP web layer and uses the below key verbs to work with resources on the server
	POST - To create a resource on the server
	GET - To retrieve a resource from the server
	PUT - To change the state of a resource or to update it
	DELETE - To remove or delete a resource from the server


RESTful Key Elements?
        1) Resources 
        2) Request Verbs
        3) Request Headers
        4) Request Body
        5) Response Body
        6) Response Status codes


Why restful?
	Heterogeneous languages and environments – 
        This is one of the fundamental reasons which is the same as we have seen for SOAP as well.
        It enables web applications that are built on various programming languages to communicate with each other
        With the help of Restful services, these web applications can reside on different environments, some could be on                                        		Windows, and others could be on Linux.


================================What are the annotation available in restful======================
	JAX-RS HTTP Method Annotations:
		@Post
		@Put
		@Patch
		@Delete
		@Get
		@Options
		@Trace
		@Head
	JAX-RS Parameter Annotations:
		@QueryParam
		@FormParam
		@PathParam
		@DefaultValue
		@Context
	JAX-RS Other annotations:
		@Path
		@Produce
		@Consume
		@HeaderParam
		@CookieParam
		@Provider
		@Crossorigion
		@MatrixParam
		
		
@Path:
It tells the relative path of the resource class or method.

@Get :
GET defines a reading access of the resource without side-effects. The resource is never changed via a GET request, e.g., the request has no side effects (idempotent).

@Put:
PUT updates an existing resource or creates a new resource.

@Post:
creates a new resource. It must also be idempotent.

@Delete:
DELETE removes the resources. The operations are idempotent. They can get repeated without leading to different results.

@PathParam:
Example-1
	@Path("/hello")  
	public class HelloService{  
	    @GET  
	    @Path("{year}/{month}/{day}")  
	    public Response getDate(  
		    @PathParam("year") int year,  
		    @PathParam("month") int month,   
		    @PathParam("day") int day) {  

	       String date = year + "/" + month + "/" + day;  

	       return Response.status(200)  
		.entity("getDate is called, year/month/day : " + date)  
		.build();  
	    }  
	 }  
@FormParam:
Example-1:
	@Path("/product")  
	public class ProductService{  
	    @POST  
	    @Path("/add")  
	    public Response addUser(  
		@FormParam("id") int id,  
		@FormParam("name") String name,  
		@FormParam("price") float price) {  

		return Response.status(200)  
		    .entity(" Product added successfuly!<br> Id: "+id+"<br> Name: " + name+"<br> Price: "+price)  
		    .build();  
	    }  
	}  
JAX-RS File Download Example:
	We can download text files, image files, pdf files, excel files in java by JAX-RS API. To do so we need to write few lines of code only. Here, we are using jersey implementation for developing JAX-RS file download examples.
	You need to specify different content type to download different files. The @Produces annotation is used to specify the type of file content.
	@Produces("text/plain"): for downloading text file.
	@Produces("image/png"): for downloading png image file.
	@Produces("application/pdf"): for downloading PDF file.
	@Produces("application/vnd.ms-excel"): for downloading excel file.
	@Produces("application/msword"): for downloading ms word file.
Example for download file:
	@Path("/files")  
	public class FileDownloadService {  
	    private static final String FILE_PATH = "c:\\myimage.png";  
	    @GET  
	    @Path("/image")  
	    @Produces("image/png")  
	    public Response getFile() {  
		File file = new File(FILE_PATH);  
		ResponseBuilder response = Response.ok((Object) file);  
		response.header("Content-Disposition","attachment; filename=\"javatpoint_image.png\"");  
		return response.build();  

	    }  
	 }  
RESTful JAX-RS File Upload Example:
	@Path("/files")  
	public class FileUploadService {  
	    @POST  
	    @Path("/upload")  
	    @Consumes(MediaType.MULTIPART_FORM_DATA)  
	    public Response uploadFile(  
		    @FormDataParam("file") InputStream uploadedInputStream,  
		    @FormDataParam("file") FormDataContentDisposition fileDetail) {  
		    String fileLocation = "e://" + fileDetail.getFileName();  
			    //saving file  
		    try {  
			FileOutputStream out = new FileOutputStream(new File(fileLocation));  
			int read = 0;  
			byte[] bytes = new byte[1024];  
			out = new FileOutputStream(new File(fileLocation));  
			while ((read = uploadedInputStream.read(bytes)) != -1) {  
			    out.write(bytes, 0, read);  
			}  
			out.flush();  
			out.close();  
		    } catch (IOException e) {e.printStackTrace();}  
		    String output = "File successfully uploaded to : " + fileLocation;  
		    return Response.status(200).entity(output).build();  
		}  
	  }  

What are the dependencies we need to implement rest API?
	<!-- for 2.0 version-->
	<properties>
		<jersey2.version>2.19</jersey2.version>
		<jaxrs.version>2.0.1</jaxrs.version>
	    </properties>
	    <dependencies>
		<!-- JAX-RS -->
		<dependency>
		    <groupId>javax.ws.rs</groupId>
		    <artifactId>javax.ws.rs-api</artifactId>
		    <version>${jaxrs.version}</version>
		</dependency>
		<!-- Jersey 2.19 -->
		<dependency>
		    <groupId>org.glassfish.jersey.containers</groupId>
		    <artifactId>jersey-container-servlet</artifactId>
		    <version>${jersey2.version}</version>
		</dependency>
		<dependency>
		    <groupId>org.glassfish.jersey.core</groupId>
		    <artifactId>jersey-server</artifactId>
		    <version>${jersey2.version}</version>
		</dependency>
		<dependency>
		    <groupId>org.glassfish.jersey.core</groupId>
		    <artifactId>jersey-client</artifactId>
		    <version>${jersey2.version}</version>
		</dependency>
		<dependency>
	   	 <groupId>org.glassfish.jersey.media</groupId>
	   	 <artifactId>jersey-media-multipart</artifactId>
	    	<version>2.19</version>
		</dependency>
		<dependency>
	   	 <groupId>org.glassfish.jersey.media</groupId>
	  	  <artifactId>jersey-media-moxy</artifactId>
	  	  <version>2.19</version>
		</dependency>
		<dependency>
  		  <groupId>org.glassfish.jersey.media</groupId>
   		 <artifactId>jersey-media-json-processing</artifactId>
   		 <version>2.19</version>
		</dependency>
		<dependency>
   		 <groupId>com.google.code.gson</groupId>
   		 <artifactId>gson</artifactId>
	    	<version>2.2.4</version>
		</dependency>
	    </dependencies>

How to configure rest API?
Servlet mapping should be updated in the web.xml to point to our web service resource.
	<?xml version="1.0" encoding="UTF-8"?>
	<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" 		xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" 		id="WebApp_ID" version="3.0">
	  <display-name>RESTful Jersey Hello World</display-name>
	  <welcome-file-list>
	    <welcome-file>index.html</welcome-file>
	    <welcome-file>index.htm</welcome-file>
	    <welcome-file>index.jsp</welcome-file>
	    <welcome-file>default.html</welcome-file>
	    <welcome-file>default.htm</welcome-file>
	    <welcome-file>default.jsp</welcome-file>
	  </welcome-file-list>

	  <servlet>
	    <servlet-name>RESTful Jersey Hello World Service</servlet-name>
	    <servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
	    <!-- for scan the package of rest resource-->
	    <init-param>
		<param-name>jersey.config.server.provider.packages</param-name>
		<param-value>com.javapapers.webservices.rest.jersey</param-value>
	    </init-param>
	   <!-- For file Upload-->
	   <init-param>  
	    <param-name>jersey.config.server.provider.classnames</param-name>  
	    <param-value>org.glassfish.jersey.filter.LoggingFilter;  
	     org.glassfish.jersey.media.multipart.MultiPartFeature</param-value>  
	  </init-param>  
	  <init-param>
            <param-name>javax.ws.rs.Application</param-name>
            <param-value>com.howtodoinjava.jersey.CustomApplication</param-value>
          </init-param>
	<init-param>
            <param-name>jersey.config.server.provider.classnames</param-name>
            <param-value>org.glassfish.jersey.filter.LoggingFilter</param-value>
        </init-param>
	    <load-on-startup>1</load-on-startup>
	  </servlet>
	  <servlet-mapping>
	    <servlet-name>RESTful Jersey Hello World Service</servlet-name>
	    <url-pattern>/rest/*</url-pattern>
	  </servlet-mapping>
	</web-app>

How to call rest API in our application?
   By using Jersey API: JAX-RS 2.0 (with Jersey 2.11) is used.
   Example-1 
	public class RESTfulJerseyClient {
	private static final String webServiceURI = "http://localhost:8080/RESTful_Jersey_Hello_World";
	public static void main(String[] args) {
		ClientConfig clientConfig = new ClientConfig();
		Client client = ClientBuilder.newClient(clientConfig);
		URI serviceURI = UriBuilder.fromUri(webServiceURI).build();
		WebTarget webTarget = client.target(serviceURI);
		// response
		System.out.println(webTarget.path("rest").path("helloworld").request()
				.accept(MediaType.TEXT_PLAIN).get(Response.class).toString());
		// text
		System.out.println(webTarget.path("rest").path("helloworld").request()
				.accept(MediaType.TEXT_PLAIN).get(String.class));
		// xml
		System.out.println(webTarget.path("rest").path("helloworld").request()
				.accept(MediaType.TEXT_XML).get(String.class));
		// html
		System.out.println(webTarget.path("rest").path("helloworld").request()
				.accept(MediaType.TEXT_HTML).get(String.class));
	}
}

Example-2:
	public class Tester {
	  public static void main(String[] args) {
	      ClientConfig config = new ClientConfig();
	      Client client = ClientBuilder.newClient(config);
	      WebTarget service = client.target(getBaseURI());
	      // create one todo
	      Todo todo = new Todo("3", "Blabla");
	      Response response = service.path("rest").path("todos").path(todo.getId()).request(MediaType.APPLICATION_XML).put(Entity.entity(todo,MediaType.APPLICATION_XML),Response.class);
	      // Return code should be 201 == created resource
	      System.out.println(response.getStatus());
	      // Get the Todos
	      System.out.println(service.path("rest").path("todos").request().accept(MediaType.TEXT_XML).get(String.class));
	//    // Get JSON for application (Make sure to add the jersey-media-json-jackson dependency to add support for JSON)
	//    System.out.println(service.path("rest").path("todos").request().accept(MediaType.APPLICATION_JSON).get(String.class));
	      // Get XML for application
	      System.out.println(service.path("rest").path("todos").request().accept(MediaType.APPLICATION_XML).get(String.class));
	      //Get Todo with id 1
	      Response checkDelete = service.path("rest").path("todos/1").request().accept(MediaType.APPLICATION_XML).get();
	      //Delete Todo with id 1
	      service.path("rest").path("todos/1").request().delete();
	      //Get get all Todos id 1 should be deleted
	      System.out.println(service.path("rest").path("todos").request().accept(MediaType.APPLICATION_XML).get(String.class));
	      //Create a Todo
	      Form form =new Form();
	      form.param("id", "4");
	      form.param("summary","Demonstration of the client lib for forms");
	      response = service.path("rest").path("todos").request().post(Entity.entity(form,MediaType.APPLICATION_FORM_URLENCODED),Response.class);
	      System.out.println("Form response " + response.getStatus());
	      //Get all the todos, id 4 should have been created
	      System.out.println(service.path("rest").path("todos").request().accept(MediaType.APPLICATION_XML).get(String.class));
	  }
	  private static URI getBaseURI() {
	    return UriBuilder.fromUri("http://localhost:8080/com.vogella.jersey.todo").build();
	  }
	}
  Example-3 for File upload jersey client
	public static void main(String[] args) throws IOException
	{
	    final Client client = ClientBuilder.newBuilder().register(MultiPartFeature.class).build();

	    final FileDataBodyPart filePart = new FileDataBodyPart("file", new File("C:/temp/sample.pdf"));
	    FormDataMultiPart formDataMultiPart = new FormDataMultiPart();
	    final FormDataMultiPart multipart = (FormDataMultiPart) formDataMultiPart.field("foo", "bar").bodyPart(filePart);

	    final WebTarget target = client.target("http://localhost:8080/JerseyDemos/rest/upload/pdf");
	    final Response response = target.request().post(Entity.entity(multipart, multipart.getMediaType()));

	    //Use response object to verify upload success

	    formDataMultiPart.close();
	    multipart.close();
	}


How to handle Exception handling in Restful?
   1. Jersey ExceptionMapper – Create custom exceptions
	@Provider
	public class MissingFileException extends Exception implements
			ExceptionMapper<MissingFileException>
	{
	    private static final long serialVersionUID = 1L;

	    public MissingFileException() {
		super("No File found with given name !!");
	    }
	    public MissingFileException(String string) {
		super(string);
	    }
	    @Override
	    public Response toResponse(MissingFileException exception)
	    {
		return Response.status(404).entity(exception.getMessage()).type("text/plain").build();
	    }
	}
	
  2.How to throw exception from REST API
	@Path("/download")
	public class JerseyService
	{
	    @GET
	    @Path("/{fileName}")
	    public Response downloadPdfFile(final @PathParam("fileName") String fileName) throws MissingFileException
	    {
		final String fullFilePath = "C:/temp/" + fileName;

		File file = new File(fullFilePath);

		if(file.exists() == false){
		    throw new MissingFileException(fileName + " does not existing on this server !!");
		}
		StreamingOutput fileStream =  new StreamingOutput()
		{
		    @Override
		    public void write(java.io.OutputStream output) throws IOException
		    {
			try
			{
			    java.nio.file.Path path = Paths.get(fullFilePath);
			    byte[] data = Files.readAllBytes(path);
			    output.write(data);
			    output.flush();
			}
			catch (IOException e)
			{
			    throw new IOException("Error while reading file :: '"+fileName+"' !!");
			}
		    }
		};
		return Response
			.ok(fileStream, MediaType.APPLICATION_OCTET_STREAM)
			.header("content-disposition","attachment; filename = '"+fileName)
			.build();
	    }
	}
  3. Uncaught Exception Handling
	@Provider
	public class UncaughtException extends Throwable implements ExceptionMapper<Throwable>
	{
	    private static final long serialVersionUID = 1L;
	    @Override
	    public Response toResponse(Throwable exception)
	    {
		return Response.status(500).entity("Something bad happened. Please try again !!").type("text/plain").build();
	    }
	}

How to handle error codes/status codes in rest?

How to write jersy cleint?

 Jersey 2 Client API
  JAX-RS Client API is a designed to allow fluent programming model. To create jersey client follow these steps –
	Use ClientBuilder.newClient() static method.
	Use client.target() method on above obtained client instance.
	Get Invocation.Builder using webTarget.request() method on WebTarget instance obtained in second step.
	Execute invocationBuilder.get(), put(), post() or delete() methods to invoke corresponding REST APIs.
	Jersey ClientBuilder Example
	--Client client = ClientBuilder.newClient( new ClientConfig().register( LoggingFilter.class ) );
	--WebTarget webTarget = client.target("http://localhost:8080/JerseyDemos/rest").path("employees");
	--Invocation.Builder invocationBuilder =  webTarget.request(MediaType.APPLICATION_XML);
	--Response response = invocationBuilder.post(Entity.entity(emp, MediaType.APPLICATION_XML));
	3. HTTP GET – Collection/List of Entities
			@GET
		@Path("/employees")
		@Produces(MediaType.APPLICATION_XML)
		public Employees getAllEmployees()
		{
		    Employees list = new Employees();
		    list.setEmployeeList(new ArrayList<Employee>());

		    list.getEmployeeList().add(new Employee(1, "Lokesh Gupta"));
		    list.getEmployeeList().add(new Employee(2, "Alex Kolenchiskey"));
		    list.getEmployeeList().add(new Employee(3, "David Kameron"));

		    return list;
		}
	This RESTful client code will access above API and print the response in the console.

		Client client = ClientBuilder.newClient( new ClientConfig().register( LoggingFilter.class ) );
		WebTarget webTarget = client.target("http://localhost:8080/JerseyDemos/rest").path("employees");

		Invocation.Builder invocationBuilder =  webTarget.request(MediaType.APPLICATION_XML);
		Response response = invocationBuilder.get();

		Employees employees = response.readEntity(Employees.class);
		List<Employee> listOfEmployees = employees.getEmployeeList();

		System.out.println(response.getStatus());
		System.out.println(Arrays.toString( listOfEmployees.toArray(new Employee[listOfEmployees.size()]) ));

		Output:

		200
		[Employee [id=1, name=Lokesh Gupta], Employee [id=2, name=Alex Kolenchiskey], Employee [id=3, name=David Kameron]]
	HTTP GET – Single Entitiy

		This is the API code written for retrieving single employee based on its id.
		@GET
		@Path("/employees/{id}")
		@Produces(MediaType.APPLICATION_XML)
		public Response updateEmployeeById(@PathParam("id") Integer id)
		{
		    if(id  < 0){
			return Response.noContent().build();
		    }
		    Employee emp = new Employee();

		    emp.setId(id);
		    emp.setName("Lokesh Gupta");

		    GenericEntity<Employee> entity = new GenericEntity<Employee>(emp, Employee.class);
		    return Response.ok().entity(entity).build();
		}
	This RESTful client code will access above API and print the response in the console.

		Client client = ClientBuilder.newClient( new ClientConfig().register( LoggingFilter.class ) );
		WebTarget webTarget = client.target("http://localhost:8080/JerseyDemos/rest").path("employees").path("1");

		Invocation.Builder invocationBuilder =  webTarget.request(MediaType.APPLICATION_XML);
		Response response = invocationBuilder.get();

		Employee employee = response.readEntity(Employee.class);

		System.out.println(response.getStatus());
		System.out.println(employee);

		Output:

		200
		Employee [id=1, name=Lokesh Gupta]
	HTTP POST
		This is the API code written for adding an employee in the collection.

		@POST
		@Path("/employees")
		@Consumes(MediaType.APPLICATION_XML)
		@Produces(MediaType.APPLICATION_XML)
		public Response addEmployee( Employee e ) throws URISyntaxException
		{
		    if(e == null){
			return Response.status(400).entity("Please add employee details !!").build();
		    }

		    if(e.getName() == null) {
			return Response.status(400).entity("Please provide the employee name !!").build();
		    }

		    return Response.created(new URI("/rest/employees/"+e.getId())).build();
		}
		Jersey Client Code

		This RESTful client code will access above API and print the response in the console.

		Client client = ClientBuilder.newClient( new ClientConfig().register( LoggingFilter.class ) );
		WebTarget webTarget = client.target("http://localhost:8080/JerseyDemos/rest").path("employees");

		Employee emp = new Employee();
		emp.setId(1);
		emp.setName("David Feezor");

		Invocation.Builder invocationBuilder =  webTarget.request(MediaType.APPLICATION_XML);
		Response response = invocationBuilder.post(Entity.entity(emp, MediaType.APPLICATION_XML));

		System.out.println(response.getStatus());
		System.out.println(response.readEntity(String.class));

		Output:

		201
		
HTTP PUT

This is the API code written for updating an employee name by its id.

@PUT
@Path("/employees/{id}")
@Consumes(MediaType.APPLICATION_XML)
@Produces(MediaType.APPLICATION_XML)
public Response updateEmployeeById(@PathParam("id") Integer id, Employee e)
{
    Employee updatedEmployee = new Employee();
     
    if(e.getName() == null) {
        return Response.status(400).entity("Please provide the employee name !!").build();
    }
     
    updatedEmployee.setId(id);
    updatedEmployee.setName(e.getName());
     
    return Response.ok().entity(updatedEmployee).build();
}
Jersey 2 Client Code

This RESTful client code will access above API and print the response in the console.

Client client = ClientBuilder.newClient( new ClientConfig().register( LoggingFilter.class ) );
WebTarget webTarget = client.target("http://localhost:8080/JerseyDemos/rest").path("employees").path("1");
 
Employee emp = new Employee();
emp.setId(1);
emp.setName("David Feezor");
 
Invocation.Builder invocationBuilder =  webTarget.request(MediaType.APPLICATION_XML);
Response response = invocationBuilder.put(Entity.entity(emp, MediaType.APPLICATION_XML));
 
Employee employee = response.readEntity(Employee.class);
     
System.out.println(response.getStatus());
System.out.println(employee);
 
Output:
 
200
Employee [id=1, name=David Feezor]
7. HTTP DELETE

This is the API code written for removing an employee from the collection by id.

@DELETE
@Path("/employees/{id}")
public Response deleteEmployeeById(@PathParam("id") Integer id)
{      
    return Response.status(202).entity("Employee deleted successfully !!").build();
}
Jersey Client Code

This RESTful client code will access above API and print the response in the console.

Client client = ClientBuilder.newClient( new ClientConfig().register( LoggingFilter.class ) );
WebTarget webTarget = client.target("http://localhost:8080/JerseyDemos/rest").path("employees").path("1");
 
Invocation.Builder invocationBuilder =  webTarget.request();
Response response = invocationBuilder.delete();
 
System.out.println(response.getStatus());
System.out.println(response.readEntity(String.class));
 
Output:
 
202
Employee deleted successfully !!
8. Model classes and Configuration files

Listed below are other used files to create this Jersey 2 client example.

Employees.java

package com.howtodoinjava.jersey;
 
import java.util.List;
 
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
 
@XmlRootElement(name = "employeeList")
@XmlAccessorType (XmlAccessType.FIELD)
public class Employees
{
    @XmlElement(name="employee")
    private List<Employee> employeeList;
 
    public List<Employee> getEmployeeList() {
        return employeeList;
    }
 
    public void setEmployeeList(List<Employee> employeeList) {
        this.employeeList = employeeList;
    }
}
Employee.java

package com.howtodoinjava.jersey;
 
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlRootElement;
 
@XmlRootElement(name = "employee")
@XmlAccessorType (XmlAccessType.FIELD)
public class Employee
{
    private Integer id;
    private String name;
     
    public Employee() {
         
    }
     
    public Employee(Integer id, String name) {
        this.id  = id;
        this.name = name;
    }
 
    public Integer getId() {
        return id;
    }
 
    public void setId(Integer id) {
        this.id = id;
    }
 
    public String getName() {
        return name;
    }
 
    public void setName(String name) {
        this.name = name;
    }
     
    @Override
    public String toString() {
        return "Employee [id=" + id + ", name=" + name + "]";
    }
}


Custom logging?

How to set Cookie in REST API Response?

	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Consumes(MediaType.APPLICATION_JSON)
	public Response getAllEployees()
	{
	    Employees list = new Employees();
	    list.setEmployeeList(new ArrayList<Employee>());

	    list.getEmployeeList().add(new Employee(1, "Lokesh Gupta"));
	    list.getEmployeeList().add(new Employee(2, "Alex Kolenchiskey"));
	    list.getEmployeeList().add(new Employee(3, "David Kameron"));

	    return Response.ok().entity(list).cookie(new NewCookie("cookieResponse", "cookieValueInReturn")).build();
	}

Jersey + MOXy JSON - Manually adding MoxyJsonFeature
	public class CustomApplication extends Application
	{
	    //Add Service APIs
	    @Override
	    public Set<Class<?>> getClasses()
	    {
		Set<Class<?>> resources = new HashSet<Class<?>>();

		//register REST modules
		resources.add(JerseyService.class);

		//Manually adding MOXyJSONFeature
		resources.add(org.glassfish.jersey.moxy.json.MoxyJsonFeature.class);

		//Configure Moxy behavior
		resources.add(JsonMoxyConfigurationContextResolver.class);

		return resources;
	    }
	}
Customize behavior using MoxyJsonConfig:
	@Provider
	public class JsonMoxyConfigurationContextResolver implements ContextResolver<MoxyJsonConfig>
	{

	    private final MoxyJsonConfig config;

	    public JsonMoxyConfigurationContextResolver()
	    {
		final Map<String, String> namespacePrefixMapper = new HashMap<String, String>();
		namespacePrefixMapper.put("http://www.w3.org/2001/XMLSchema-instance", "xsi");

		config = new MoxyJsonConfig()
			.setNamespacePrefixMapper(namespacePrefixMapper)
			.setNamespaceSeparator(':')
			.setAttributePrefix("")
			.setValueWrapper("value")
			.property(JAXBContextProperties.JSON_WRAPPER_AS_ARRAY_NAME, true)
			.setFormattedOutput(true)
			.setIncludeRoot(true)
			.setMarshalEmptyCollections(true);
	    }

	    @Override
	    public MoxyJsonConfig getContext(Class<?> objectType)
	    {
		return config;
	    }
	}
Jersey + JSONP Example
	public class CustomApplication extends ResourceConfig
	{
	    public CustomApplication()
	    {
		register(JsonProcessingFeature.class);
		packages("com.howtodoinjava.jersey");
		packages("org.glassfish.jersey.examples.jsonp");
		register(LoggingFilter.class);
		property(JsonGenerator.PRETTY_PRINTING, true);

	    }
	}
Jersey + Google Gson Example
	public class GsonMessageBodyHandler implements MessageBodyWriter<Object>,
		MessageBodyReader<Object> {
	    private static final String UTF_8 = "UTF-8";

	    private Gson gson;

	    //Customize the gson behavior here
	    private Gson getGson() {
		if (gson == null) {
		    final GsonBuilder gsonBuilder = new GsonBuilder();
		    gson = gsonBuilder.disableHtmlEscaping()
			    .setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)
			    .setPrettyPrinting()
			    .serializeNulls()
			    .create();
		}
		return gson;
	    }

	    @Override
	    public boolean isReadable(Class<?> type, Type genericType,
		    java.lang.annotation.Annotation[] annotations, MediaType mediaType) {
		return true;
	    }

	    @Override
	    public Object readFrom(Class<Object> type, Type genericType,
		    Annotation[] annotations, MediaType mediaType,
		    MultivaluedMap<String, String> httpHeaders, InputStream entityStream) {
		InputStreamReader streamReader = null;
		try {
		    streamReader = new InputStreamReader(entityStream, UTF_8);
		} catch (UnsupportedEncodingException e) {
		    e.printStackTrace();
		}
		try {
		    Type jsonType;
		    if (type.equals(genericType)) {
			jsonType = type;
		    } else {
			jsonType = genericType;
		    }
		    return getGson().fromJson(streamReader, jsonType);
		} finally {
		    try {
			streamReader.close();
		    } catch (IOException e) {
			e.printStackTrace();
		    }
		}
	    }

	    @Override
	    public boolean isWriteable(Class<?> type, Type genericType,
		    Annotation[] annotations, MediaType mediaType) {
		return true;
	    }

	    @Override
	    public long getSize(Object object, Class<?> type, Type genericType,
		    Annotation[] annotations, MediaType mediaType) {
		return -1;
	    }

	    @Override
	    public void writeTo(Object object, Class<?> type, Type genericType,
		    Annotation[] annotations, MediaType mediaType,
		    MultivaluedMap<String, Object> httpHeaders,
		    OutputStream entityStream) throws IOException,
		    WebApplicationException {
		OutputStreamWriter writer = new OutputStreamWriter(entityStream, UTF_8);
		try {
		    Type jsonType;
		    if (type.equals(genericType)) {
			jsonType = type;
		    } else {
			jsonType = genericType;
		    }
		    getGson().toJson(object, jsonType, writer);
		} finally {
		    writer.close();
		}
	    }
	}
	Register Gson Provider

	Now register above class with application resource config.

	package com.howtodoinjava.jersey;

	import org.glassfish.jersey.filter.LoggingFilter;
	import org.glassfish.jersey.server.ResourceConfig;
	import com.howtodoinjava.jersey.provider.GsonMessageBodyHandler;

	public class CustomApplication extends ResourceConfig
	{
	    public CustomApplication()
	    {
		packages("com.howtodoinjava.jersey");
		register(LoggingFilter.class);
		register(GsonMessageBodyHandler.class);
	    }
	}
	Extending Gson Functionality

	You can extend/customize Gson behavior anytime inside GsonMessageBodyHandler.getGson() method.

	private Gson getGson() {
	    if (gson == null) {
		final GsonBuilder gsonBuilder = new GsonBuilder();
		gson = gsonBuilder.disableHtmlEscaping()
			.setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)
			.setPrettyPrinting()
			.serializeNulls()
			.create();
	    }
	    return gson;
	}
	
	
Jersey REST API Security Example

@Provider
public class AuthenticationFilter implements javax.ws.rs.container.ContainerRequestFilter
{
     
    @Context
    private ResourceInfo resourceInfo;
     
    private static final String AUTHORIZATION_PROPERTY = "Authorization";
    private static final String AUTHENTICATION_SCHEME = "Basic";
      
    @Override
    public void filter(ContainerRequestContext requestContext)
    {
        Method method = resourceInfo.getResourceMethod();
        //Access allowed for all
        if( ! method.isAnnotationPresent(PermitAll.class))
        {
            //Access denied for all
            if(method.isAnnotationPresent(DenyAll.class))
            {
                requestContext.abortWith(Response.status(Response.Status.FORBIDDEN)
                         .entity("Access blocked for all users !!").build(););
                return;
            }
              
            //Get request headers
            final MultivaluedMap<String, String> headers = requestContext.getHeaders();
              
            //Fetch authorization header
            final List<String> authorization = headers.get(AUTHORIZATION_PROPERTY);
              
            //If no authorization information present; block access
            if(authorization == null || authorization.isEmpty())
            {
                requestContext.abortWith(Response.status(Response.Status.UNAUTHORIZED)
                    .entity("You cannot access this resource").build());
                return;
            }
              
            //Get encoded username and password
            final String encodedUserPassword = authorization.get(0).replaceFirst(AUTHENTICATION_SCHEME + " ", "");
              
            //Decode username and password
            String usernameAndPassword = new String(Base64.decode(encodedUserPassword.getBytes()));;
  
            //Split username and password tokens
            final StringTokenizer tokenizer = new StringTokenizer(usernameAndPassword, ":");
            final String username = tokenizer.nextToken();
            final String password = tokenizer.nextToken();
              
            //Verifying Username and password
            System.out.println(username);
            System.out.println(password);
              
            //Verify user access
            if(method.isAnnotationPresent(RolesAllowed.class))
            {
                RolesAllowed rolesAnnotation = method.getAnnotation(RolesAllowed.class);
                Set<String> rolesSet = new HashSet<String>(Arrays.asList(rolesAnnotation.value()));
                  
                //Is user valid?
                if( ! isUserAllowed(username, password, rolesSet))
                {
                    requestContext.abortWith(Response.status(Response.Status.UNAUTHORIZED)
                        .entity("You cannot access this resource").build(););
                    return;
                }
            }
        }
    }
    private boolean isUserAllowed(final String username, final String password, final Set<String> rolesSet)
    {
        boolean isAllowed = false;
          
        //Step 1. Fetch password from database and match with password in argument
        //If both match then get the defined role for user from database and continue; else return isAllowed [false]
        //Access the database and do this part yourself
        //String userRole = userMgr.getUserRole(username);
         
        if(username.equals("howtodoinjava") && password.equals("password"))
        {
            String userRole = "ADMIN";
             
            //Step 2. Verify user role
            if(rolesSet.contains(userRole))
            {
                isAllowed = true;
            }
        }
        return isAllowed;
    }
}

public class CustomApplication extends ResourceConfig
{
    public CustomApplication()
    {
        packages("com.howtodoinjava.jersey");
        register(LoggingFilter.class);
        register(GsonMessageBodyHandler.class);
 
        //Register Auth Filter here
        register(AuthenticationFilter.class);
    }
}

@Path("/employees")
public class JerseyService
{
    @RolesAllowed("ADMIN")
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public Employees getAllEmployees()
    {
        Employees list = new Employees();
        list.setEmployeeList(new ArrayList<Employee>());
         
        list.getEmployeeList().add(new Employee(1, "Lokesh Gupta"));
        list.getEmployeeList().add(new Employee(2, "Alex Kolenchiskey"));
        list.getEmployeeList().add(new Employee(3, "David Kameron"));
         
        return list;
    }
}  

===============================Jersey REST Client Authentication Example=====================================
1. Jersey Client – HttpAuthenticationFeature

HttpAuthenticationFeature class provides HttpBasic and Digest client authentication capabilities. The feature work in one of 4 modes i.e. BASIC, BASIC NON-PREEMPTIVE, DIGEST and UNIVERSAL. Let’s quickly learn about them.

BASIC – It’s preemptive authentication way i.e. information is send always with each HTTP request. This mode must be combined with usage of SSL/TLS as the password is send only BASE64 encoded.
BASIC NON-PREEMPTIVE – It’s non-preemptive authentication way i.e. auth information is added only when server refuses the request with 401 status code and then the request is repeated with authentication information.
DIGEST – Http digest authentication. Does not require usage of SSL/TLS.
UNIVERSAL – Combination of basic and digest authentication in non-preemptive mode i.e. in case of 401 response, an appropriate authentication is used based on the authentication requested as defined in WWW-Authenticate HTTP header.
To use HttpAuthenticationFeature, build an instance of it and register with client.

1.1. Basic authentication mode
HttpAuthenticationFeature feature = HttpAuthenticationFeature.basic("username", "password"); 
final Client client = ClientBuilder.newClient();
client.register(feature);

1.2. Basic authentication – non-prempitive mode
HttpAuthenticationFeature feature = HttpAuthenticationFeature.basicBuilder()
                                    .nonPreemptive()
                                    .credentials("username", "password")
                                    .build();

final Client client = ClientBuilder.newClient();
client.register(feature);

1.3. Universal mode
//HttpAuthenticationFeature feature = HttpAuthenticationFeature.universal("username", "password");

//Universal builder having different credentials for different schemes
HttpAuthenticationFeature feature = HttpAuthenticationFeature.universalBuilder()
                .credentialsForBasic("username1", "password1")
                .credentials("username2", "password2").build();
final Client client = ClientBuilder.newClient();
client.register(feature);

2. How to secure REST APIs

For authentication enabled rest apis, use roles related annotations, such as @RolesAllowed. For example, this is the code of secured REST API.

@Path("/employees")
public class JerseyService
{
    @RolesAllowed("ADMIN")
    @GET
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public Employees getAllEmployees()
    {
        Employees list = new Employees();
        list.setEmployeeList(new ArrayList<Employee>());
         
        list.getEmployeeList().add(new Employee(1, "Lokesh Gupta"));
        list.getEmployeeList().add(new Employee(2, "Alex Kolenchiskey"));
        list.getEmployeeList().add(new Employee(3, "David Kameron"));
         
        return list;
    }
}

3. Jersey REST Client Code

Below is the jersey rest client basic authentication example which accept username and password details for authentication purpose.

public static void main(String[] args) throws IOException
{
    httpGETCollectionExample();
}
 
private static void httpGETCollectionExample()
{
    ClientConfig clientConfig = new ClientConfig();
 
    HttpAuthenticationFeature feature = HttpAuthenticationFeature.basic("howtodoinjava", "password");
    clientConfig.register( feature) ;
 
    clientConfig.register(JacksonFeature.class);
 
    Client client = ClientBuilder.newClient( clientConfig );
    WebTarget webTarget = client.target("http://localhost:8080/JerseyDemos/rest").path("employees");
     
    Invocation.Builder invocationBuilder =  webTarget.request(MediaType.APPLICATION_JSON);
    Response response = invocationBuilder.get();
     
    System.out.println(response.getStatus());
    System.out.println(response.getStatusInfo());
     
    if(response.getStatus() == 200)
    {
        Employees employees = response.readEntity(Employees.class);
        List<Employee> listOfEmployees = employees.getEmployeeList();
        System.out.println(Arrays.toString( listOfEmployees.toArray(new Employee[listOfEmployees.size()]) ));
    }
}


=====================================Jersey Client – Set Cookie ==============================================
Rest API Code

I have written below REST API for testing purpose.

@GET
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public Employees getAllEployees(@CookieParam(value="cookieParam1") String cookieParam1,
                                @CookieParam(value="cookieParam2") String cookieParam2)
{
    System.out.println("cookieParam1 is :: "+ cookieParam1);
    System.out.println("cookieParam2 is :: "+ cookieParam2);
     
    Employees list = new Employees();
    list.setEmployeeList(new ArrayList<Employee>());
     
    list.getEmployeeList().add(new Employee(1, "Lokesh Gupta"));
    list.getEmployeeList().add(new Employee(2, "Alex Kolenchiskey"));
    list.getEmployeeList().add(new Employee(3, "David Kameron"));
     
    return list;
}

Now let’s call above REST API using Jersey client code as suggested in first heading.

public static void main(String[] args)
{
    Client client = ClientBuilder.newClient( new ClientConfig().register( LoggingFilter.class ) );
    WebTarget webTarget = client.target("http://localhost:8080/JerseyDemos/rest").path("employees");
      
    Invocation.Builder invocationBuilder =  webTarget.request(MediaType.APPLICATION_JSON);
    Response response = invocationBuilder
                                .cookie("cookieParam1","cookieValue1")
                                .cookie(new Cookie("cookieParam2", "cookieValue2"))
                                .get();
      
    Employees employees = response.readEntity(Employees.class);
    List<Employee> listOfEmployees = employees.getEmployeeList();
          
    System.out.println(response.getStatus());
    System.out.println(Arrays.toString( listOfEmployees.toArray(new Employee[listOfEmployees.size()]) ));
}


===============================List of Status codes==========================================================


