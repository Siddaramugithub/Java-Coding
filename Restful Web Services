
What is restful?
	REST (REpresentational State Transfer) is an architectural style for developing web services.Restful is implements the REST architectural style.
	REST is an architectural style which is based on web-standards and the HTTP protocol. 
	 A resource is accessed via a common interface based on the HTTP standard methods. 
	 A REST client can access and modify the REST resources.
	 REST allows that resources have different representations, e.g., text, XML, JSON etc. The REST client can ask for a specific representation via the HTTP protocol (content negotiation).


	
RESTFul Principles and Constraints
The architecture is client/server, stateless, layered, and supports caching –
1)RESTFul Client-Server:
	Client-server is the typical architecture where the server can be the web server hosting the application, and the client can be as simple as the web browser.
	The client send's a request to the web service on the server. The server would either reject the request or comply and provide an adequate response to the client.
2)Stateless:
	Stateless means that the state of the application is not maintained in REST.
	For example, if you delete a resource from a server using the DELETE command, you cannot expect that delete information 	to be passed to the next request.
3)Cache:
	The Cache concept is to help with the problem of stateless which was described in the last point. 
	Since each server client request is independent in nature, sometimes the client might ask the server for the same 	request again. 
	This request will go to the server, and the server will give a response. This increases the traffic across the network. The cache is a concept implemented on the client to store requests which have already been sent to the server. So if the same request is given by the client, instead of going to the server, it would go to the cache and get the required information. 
 4)Layered System
	The concept of a layered system is that any additional layer such as a middleware layer can be inserted between the client and the actual server hosting the RESTFul web service (The middleware layer is where all the business logic is created. This can be an extra service created with which the client could interact with before it makes a call to the web service.). But the introduction of this layer needs to be transparent so that it does not disturb the interaction between the client and the server.

5)Interface/Uniform Contract
	This is the underlying technique of how RESTful web services should work. RESTful basically works on the HTTP web layer and uses the below key verbs to work with resources on the server
	POST - To create a resource on the server
	GET - To retrieve a resource from the server
	PUT - To change the state of a resource or to update it
	DELETE - To remove or delete a resource from the server


RESTful Key Elements?
        1) Resources 
        2) Request Verbs
        3) Request Headers
        4) Request Body
        5) Response Body
        6) Response Status codes


Why restful?
	Heterogeneous languages and environments – 
        This is one of the fundamental reasons which is the same as we have seen for SOAP as well.
        It enables web applications that are built on various programming languages to communicate with each other
        With the help of Restful services, these web applications can reside on different environments, some could be on                                        		Windows, and others could be on Linux.


What are the annotation available in restful
	JAX-RS HTTP Method Annotations:
		@Post
		@Put
		@Patch
		@Delete
		@Get
		@Options
		@Trace
		@Head
	JAX-RS Parameter Annotations:
		@QueryParam
		@FormParam
		@PathParam
		@DefaultValue
		@Context
	JAX-RS Other annotations:
		@Path
		@Produce
		@Consume
		@HeaderParam
		@CookieParam
		@Provider
		@Crossorigion
		@MatrixParam
		
		
@Path:
It tells the relative path of the resource class or method.

@Get :
GET defines a reading access of the resource without side-effects. The resource is never changed via a GET request, e.g., the request has no side effects (idempotent).

@Put:
PUT updates an existing resource or creates a new resource.

@Post:
creates a new resource. It must also be idempotent.

@Delete:
DELETE removes the resources. The operations are idempotent. They can get repeated without leading to different results.

@PathParam:
Example-1
	@Path("/hello")  
	public class HelloService{  
	    @GET  
	    @Path("{year}/{month}/{day}")  
	    public Response getDate(  
		    @PathParam("year") int year,  
		    @PathParam("month") int month,   
		    @PathParam("day") int day) {  

	       String date = year + "/" + month + "/" + day;  

	       return Response.status(200)  
		.entity("getDate is called, year/month/day : " + date)  
		.build();  
	    }  
	 }  
@FormParam:
Example-1:
	@Path("/product")  
	public class ProductService{  
	    @POST  
	    @Path("/add")  
	    public Response addUser(  
		@FormParam("id") int id,  
		@FormParam("name") String name,  
		@FormParam("price") float price) {  

		return Response.status(200)  
		    .entity(" Product added successfuly!<br> Id: "+id+"<br> Name: " + name+"<br> Price: "+price)  
		    .build();  
	    }  
	}  
JAX-RS File Download Example:
	We can download text files, image files, pdf files, excel files in java by JAX-RS API. To do so we need to write few lines of code only. Here, we are using jersey implementation for developing JAX-RS file download examples.
	You need to specify different content type to download different files. The @Produces annotation is used to specify the type of file content.
	@Produces("text/plain"): for downloading text file.
	@Produces("image/png"): for downloading png image file.
	@Produces("application/pdf"): for downloading PDF file.
	@Produces("application/vnd.ms-excel"): for downloading excel file.
	@Produces("application/msword"): for downloading ms word file.
Example for download file:
	@Path("/files")  
	public class FileDownloadService {  
	    private static final String FILE_PATH = "c:\\myimage.png";  
	    @GET  
	    @Path("/image")  
	    @Produces("image/png")  
	    public Response getFile() {  
		File file = new File(FILE_PATH);  
		ResponseBuilder response = Response.ok((Object) file);  
		response.header("Content-Disposition","attachment; filename=\"javatpoint_image.png\"");  
		return response.build();  

	    }  
	 }  
RESTful JAX-RS File Upload Example:
	@Path("/files")  
	public class FileUploadService {  
	    @POST  
	    @Path("/upload")  
	    @Consumes(MediaType.MULTIPART_FORM_DATA)  
	    public Response uploadFile(  
		    @FormDataParam("file") InputStream uploadedInputStream,  
		    @FormDataParam("file") FormDataContentDisposition fileDetail) {  
		    String fileLocation = "e://" + fileDetail.getFileName();  
			    //saving file  
		    try {  
			FileOutputStream out = new FileOutputStream(new File(fileLocation));  
			int read = 0;  
			byte[] bytes = new byte[1024];  
			out = new FileOutputStream(new File(fileLocation));  
			while ((read = uploadedInputStream.read(bytes)) != -1) {  
			    out.write(bytes, 0, read);  
			}  
			out.flush();  
			out.close();  
		    } catch (IOException e) {e.printStackTrace();}  
		    String output = "File successfully uploaded to : " + fileLocation;  
		    return Response.status(200).entity(output).build();  
		}  
	  }  

What are the dependencies we need to implement rest API?
	<!-- for 2.0 version-->
	<properties>
		<jersey2.version>2.19</jersey2.version>
		<jaxrs.version>2.0.1</jaxrs.version>
	    </properties>
	    <dependencies>
		<!-- JAX-RS -->
		<dependency>
		    <groupId>javax.ws.rs</groupId>
		    <artifactId>javax.ws.rs-api</artifactId>
		    <version>${jaxrs.version}</version>
		</dependency>
		<!-- Jersey 2.19 -->
		<dependency>
		    <groupId>org.glassfish.jersey.containers</groupId>
		    <artifactId>jersey-container-servlet</artifactId>
		    <version>${jersey2.version}</version>
		</dependency>
		<dependency>
		    <groupId>org.glassfish.jersey.core</groupId>
		    <artifactId>jersey-server</artifactId>
		    <version>${jersey2.version}</version>
		</dependency>
		<dependency>
		    <groupId>org.glassfish.jersey.core</groupId>
		    <artifactId>jersey-client</artifactId>
		    <version>${jersey2.version}</version>
		</dependency>
		<dependency>
	   	 <groupId>org.glassfish.jersey.media</groupId>
	   	 <artifactId>jersey-media-multipart</artifactId>
	    	<version>2.19</version>
		</dependency>
		<dependency>
	   	 <groupId>org.glassfish.jersey.media</groupId>
	  	  <artifactId>jersey-media-moxy</artifactId>
	  	  <version>2.19</version>
		</dependency>
		<dependency>
  		  <groupId>org.glassfish.jersey.media</groupId>
   		 <artifactId>jersey-media-json-processing</artifactId>
   		 <version>2.19</version>
		</dependency>
	    </dependencies>

How to configure rest API?
Servlet mapping should be updated in the web.xml to point to our web service resource.
	<?xml version="1.0" encoding="UTF-8"?>
	<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" 		xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd" 		id="WebApp_ID" version="3.0">
	  <display-name>RESTful Jersey Hello World</display-name>
	  <welcome-file-list>
	    <welcome-file>index.html</welcome-file>
	    <welcome-file>index.htm</welcome-file>
	    <welcome-file>index.jsp</welcome-file>
	    <welcome-file>default.html</welcome-file>
	    <welcome-file>default.htm</welcome-file>
	    <welcome-file>default.jsp</welcome-file>
	  </welcome-file-list>

	  <servlet>
	    <servlet-name>RESTful Jersey Hello World Service</servlet-name>
	    <servlet-class>org.glassfish.jersey.servlet.ServletContainer</servlet-class>
	    <!-- for scan the package of rest resource-->
	    <init-param>
		<param-name>jersey.config.server.provider.packages</param-name>
		<param-value>com.javapapers.webservices.rest.jersey</param-value>
	    </init-param>
	   <!-- For file Upload-->
	   <init-param>  
	    <param-name>jersey.config.server.provider.classnames</param-name>  
	    <param-value>org.glassfish.jersey.filter.LoggingFilter;  
	     org.glassfish.jersey.media.multipart.MultiPartFeature</param-value>  
	  </init-param>  
	  <init-param>
            <param-name>javax.ws.rs.Application</param-name>
            <param-value>com.howtodoinjava.jersey.CustomApplication</param-value>
          </init-param>
	    <load-on-startup>1</load-on-startup>
	  </servlet>
	  <servlet-mapping>
	    <servlet-name>RESTful Jersey Hello World Service</servlet-name>
	    <url-pattern>/rest/*</url-pattern>
	  </servlet-mapping>
	</web-app>

How to call rest API in our application?
   By using Jersey API: JAX-RS 2.0 (with Jersey 2.11) is used.
   Example-1 
	public class RESTfulJerseyClient {
	private static final String webServiceURI = "http://localhost:8080/RESTful_Jersey_Hello_World";
	public static void main(String[] args) {
		ClientConfig clientConfig = new ClientConfig();
		Client client = ClientBuilder.newClient(clientConfig);
		URI serviceURI = UriBuilder.fromUri(webServiceURI).build();
		WebTarget webTarget = client.target(serviceURI);
		// response
		System.out.println(webTarget.path("rest").path("helloworld").request()
				.accept(MediaType.TEXT_PLAIN).get(Response.class).toString());
		// text
		System.out.println(webTarget.path("rest").path("helloworld").request()
				.accept(MediaType.TEXT_PLAIN).get(String.class));
		// xml
		System.out.println(webTarget.path("rest").path("helloworld").request()
				.accept(MediaType.TEXT_XML).get(String.class));
		// html
		System.out.println(webTarget.path("rest").path("helloworld").request()
				.accept(MediaType.TEXT_HTML).get(String.class));
	}
}

Example-2:
	public class Tester {
	  public static void main(String[] args) {
	      ClientConfig config = new ClientConfig();
	      Client client = ClientBuilder.newClient(config);
	      WebTarget service = client.target(getBaseURI());
	      // create one todo
	      Todo todo = new Todo("3", "Blabla");
	      Response response = service.path("rest").path("todos").path(todo.getId()).request(MediaType.APPLICATION_XML).put(Entity.entity(todo,MediaType.APPLICATION_XML),Response.class);
	      // Return code should be 201 == created resource
	      System.out.println(response.getStatus());
	      // Get the Todos
	      System.out.println(service.path("rest").path("todos").request().accept(MediaType.TEXT_XML).get(String.class));
	//    // Get JSON for application (Make sure to add the jersey-media-json-jackson dependency to add support for JSON)
	//    System.out.println(service.path("rest").path("todos").request().accept(MediaType.APPLICATION_JSON).get(String.class));
	      // Get XML for application
	      System.out.println(service.path("rest").path("todos").request().accept(MediaType.APPLICATION_XML).get(String.class));
	      //Get Todo with id 1
	      Response checkDelete = service.path("rest").path("todos/1").request().accept(MediaType.APPLICATION_XML).get();
	      //Delete Todo with id 1
	      service.path("rest").path("todos/1").request().delete();
	      //Get get all Todos id 1 should be deleted
	      System.out.println(service.path("rest").path("todos").request().accept(MediaType.APPLICATION_XML).get(String.class));
	      //Create a Todo
	      Form form =new Form();
	      form.param("id", "4");
	      form.param("summary","Demonstration of the client lib for forms");
	      response = service.path("rest").path("todos").request().post(Entity.entity(form,MediaType.APPLICATION_FORM_URLENCODED),Response.class);
	      System.out.println("Form response " + response.getStatus());
	      //Get all the todos, id 4 should have been created
	      System.out.println(service.path("rest").path("todos").request().accept(MediaType.APPLICATION_XML).get(String.class));
	  }
	  private static URI getBaseURI() {
	    return UriBuilder.fromUri("http://localhost:8080/com.vogella.jersey.todo").build();
	  }
	}
  Example-3 for File upload jersey client
	public static void main(String[] args) throws IOException
	{
	    final Client client = ClientBuilder.newBuilder().register(MultiPartFeature.class).build();

	    final FileDataBodyPart filePart = new FileDataBodyPart("file", new File("C:/temp/sample.pdf"));
	    FormDataMultiPart formDataMultiPart = new FormDataMultiPart();
	    final FormDataMultiPart multipart = (FormDataMultiPart) formDataMultiPart.field("foo", "bar").bodyPart(filePart);

	    final WebTarget target = client.target("http://localhost:8080/JerseyDemos/rest/upload/pdf");
	    final Response response = target.request().post(Entity.entity(multipart, multipart.getMediaType()));

	    //Use response object to verify upload success

	    formDataMultiPart.close();
	    multipart.close();
	}


How to handle Exception handling in Restful?
   1. Jersey ExceptionMapper – Create custom exceptions
	@Provider
	public class MissingFileException extends Exception implements
			ExceptionMapper<MissingFileException>
	{
	    private static final long serialVersionUID = 1L;

	    public MissingFileException() {
		super("No File found with given name !!");
	    }
	    public MissingFileException(String string) {
		super(string);
	    }
	    @Override
	    public Response toResponse(MissingFileException exception)
	    {
		return Response.status(404).entity(exception.getMessage()).type("text/plain").build();
	    }
	}
	
  2.How to throw exception from REST API
	@Path("/download")
	public class JerseyService
	{
	    @GET
	    @Path("/{fileName}")
	    public Response downloadPdfFile(final @PathParam("fileName") String fileName) throws MissingFileException
	    {
		final String fullFilePath = "C:/temp/" + fileName;

		File file = new File(fullFilePath);

		if(file.exists() == false){
		    throw new MissingFileException(fileName + " does not existing on this server !!");
		}
		StreamingOutput fileStream =  new StreamingOutput()
		{
		    @Override
		    public void write(java.io.OutputStream output) throws IOException
		    {
			try
			{
			    java.nio.file.Path path = Paths.get(fullFilePath);
			    byte[] data = Files.readAllBytes(path);
			    output.write(data);
			    output.flush();
			}
			catch (IOException e)
			{
			    throw new IOException("Error while reading file :: '"+fileName+"' !!");
			}
		    }
		};
		return Response
			.ok(fileStream, MediaType.APPLICATION_OCTET_STREAM)
			.header("content-disposition","attachment; filename = '"+fileName)
			.build();
	    }
	}
  3. Uncaught Exception Handling
	@Provider
	public class UncaughtException extends Throwable implements ExceptionMapper<Throwable>
	{
	    private static final long serialVersionUID = 1L;
	    @Override
	    public Response toResponse(Throwable exception)
	    {
		return Response.status(500).entity("Something bad happened. Please try again !!").type("text/plain").build();
	    }
	}

How to handle error codes/status codes in rest?

How to write jersy cleint?

Custom logging?

How to set Cookie in REST API Response?

	@GET
	@Produces(MediaType.APPLICATION_JSON)
	@Consumes(MediaType.APPLICATION_JSON)
	public Response getAllEployees()
	{
	    Employees list = new Employees();
	    list.setEmployeeList(new ArrayList<Employee>());

	    list.getEmployeeList().add(new Employee(1, "Lokesh Gupta"));
	    list.getEmployeeList().add(new Employee(2, "Alex Kolenchiskey"));
	    list.getEmployeeList().add(new Employee(3, "David Kameron"));

	    return Response.ok().entity(list).cookie(new NewCookie("cookieResponse", "cookieValueInReturn")).build();
	}

Jersey + MOXy JSON - Manually adding MoxyJsonFeature
	public class CustomApplication extends Application
	{
	    //Add Service APIs
	    @Override
	    public Set<Class<?>> getClasses()
	    {
		Set<Class<?>> resources = new HashSet<Class<?>>();

		//register REST modules
		resources.add(JerseyService.class);

		//Manually adding MOXyJSONFeature
		resources.add(org.glassfish.jersey.moxy.json.MoxyJsonFeature.class);

		//Configure Moxy behavior
		resources.add(JsonMoxyConfigurationContextResolver.class);

		return resources;
	    }
	}
Customize behavior using MoxyJsonConfig:
	@Provider
	public class JsonMoxyConfigurationContextResolver implements ContextResolver<MoxyJsonConfig>
	{

	    private final MoxyJsonConfig config;

	    public JsonMoxyConfigurationContextResolver()
	    {
		final Map<String, String> namespacePrefixMapper = new HashMap<String, String>();
		namespacePrefixMapper.put("http://www.w3.org/2001/XMLSchema-instance", "xsi");

		config = new MoxyJsonConfig()
			.setNamespacePrefixMapper(namespacePrefixMapper)
			.setNamespaceSeparator(':')
			.setAttributePrefix("")
			.setValueWrapper("value")
			.property(JAXBContextProperties.JSON_WRAPPER_AS_ARRAY_NAME, true)
			.setFormattedOutput(true)
			.setIncludeRoot(true)
			.setMarshalEmptyCollections(true);
	    }

	    @Override
	    public MoxyJsonConfig getContext(Class<?> objectType)
	    {
		return config;
	    }
	}
List of Status codes


9986190234
310873 booking no
cash memo number 1238582
684766 consumer
